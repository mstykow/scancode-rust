/// Binary that generates docs/SUPPORTED_FORMATS.md from parser metadata.
///
/// This tool collects all registered parser metadata using the `inventory` crate
/// and generates a markdown table documenting all supported package formats.
use scancode_rust::parsers::metadata::ParserMetadata;
use std::fs;
use std::path::Path;

fn main() {
    let args: Vec<String> = std::env::args().collect();
    let check_mode = args.get(1).map(|s| s.as_str()) == Some("--check");

    let output = generate_markdown();

    if check_mode {
        // Verify that docs/SUPPORTED_FORMATS.md matches the generated output
        let docs_path = Path::new("docs/SUPPORTED_FORMATS.md");
        match fs::read_to_string(docs_path) {
            Ok(existing) => {
                if existing.trim() == output.trim() {
                    println!("✓ docs/SUPPORTED_FORMATS.md is up to date");
                    std::process::exit(0);
                } else {
                    eprintln!("✗ docs/SUPPORTED_FORMATS.md is out of date");
                    eprintln!("Run: cargo run --bin generate-supported-formats");
                    std::process::exit(1);
                }
            }
            Err(e) => {
                eprintln!("✗ Failed to read {}: {}", docs_path.display(), e);
                std::process::exit(1);
            }
        }
    } else {
        // Write the generated markdown to docs/SUPPORTED_FORMATS.md
        let docs_path = Path::new("docs/SUPPORTED_FORMATS.md");
        fs::write(docs_path, &output).expect("Failed to write docs/SUPPORTED_FORMATS.md");
        println!("✓ Generated {}", docs_path.display());
    }
}

fn generate_markdown() -> String {
    // Collect all registered parsers
    let mut parsers: Vec<&ParserMetadata> = inventory::iter::<ParserMetadata>().collect();

    // Sort by package_type for deterministic output
    parsers.sort_by(|a, b| {
        a.package_type
            .cmp(b.package_type)
            .then(a.description.cmp(b.description))
    });

    let mut output = String::new();

    // Header
    output.push_str("# Supported Package Formats\n\n");
    output.push_str("> **⚠️ AUTO-GENERATED FILE** - Do not edit manually.\n");
    output.push_str("> This file is automatically generated from parser metadata.\n");
    output.push_str("> To update, run: `cargo run --bin generate-supported-formats`\n\n");

    output.push_str(&format!(
        "scancode-rust supports **{}** package formats across {} ecosystems.\n\n",
        parsers.len(),
        count_unique_package_types(&parsers)
    ));

    // Table
    output.push_str("| Description | File Patterns | Package Type | Language | Documentation |\n");
    output.push_str("|-------------|---------------|--------------|----------|---------------|\n");

    for parser in &parsers {
        let description = parser.description;
        let patterns = parser.file_patterns.join(", ");
        let package_type = parser.package_type;
        let language = parser.primary_language;
        let docs = match parser.documentation_url {
            Some(url) => format!("[Link]({})", url),
            None => "-".to_string(),
        };

        output.push_str(&format!(
            "| {} | `{}` | {} | {} | {} |\n",
            description, patterns, package_type, language, docs
        ));
    }

    output
}

fn count_unique_package_types(parsers: &[&ParserMetadata]) -> usize {
    let mut types = std::collections::HashSet::new();
    for parser in parsers {
        types.insert(parser.package_type);
    }
    types.len()
}
