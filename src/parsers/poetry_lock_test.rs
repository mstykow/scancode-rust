#[cfg(test)]
mod tests {
    use crate::parsers::{PackageParser, PoetryLockParser};
    use crate::test_utils::compare_package_data_parser_only;
    use std::path::PathBuf;

    #[test]
    fn test_parse_poetry_lock_golden() {
        let test_file = PathBuf::from("testdata/python/golden/poetry_lock/poetry.lock");
        let expected_file =
            PathBuf::from("testdata/python/golden/poetry_lock/poetry.lock-expected.json");

        let package_data = PoetryLockParser::extract_package_data(&test_file);

        assert_eq!(package_data.dependencies.len(), 5);

        match compare_package_data_parser_only(&package_data, &expected_file) {
            Ok(_) => (),
            Err(e) => panic!("Golden test failed: {}", e),
        }
    }

    #[test]
    fn test_poetry_lock_optional_field_handling() {
        use std::fs;
        use tempfile::TempDir;

        let content = r#"# This file is automatically @generated by Poetry 1.8.3 and should not be changed by hand.

[[package]]
name = "requests"
version = "2.31.0"
description = "Python HTTP for Humans."
optional = false
python-versions = ">=3.7"
files = [
    {file = "requests-2.31.0-py3-none-any.whl", hash = "sha256:test"},
]

[[package]]
name = "pytest"
version = "7.4.0"
description = "pytest: simple powerful testing with Python"
optional = true
python-versions = ">=3.7"
files = [
    {file = "pytest-7.4.0-py3-none-any.whl", hash = "sha256:test"},
]

[metadata]
lock-version = "2.0"
python-versions = "^3.8"
content-hash = "test"
"#;

        let temp_dir = TempDir::new().expect("Failed to create temp dir");
        let lock_path = temp_dir.path().join("poetry.lock");
        fs::write(&lock_path, content).expect("Failed to write poetry.lock");

        let package_data = PoetryLockParser::extract_package_data(&lock_path);

        assert_eq!(package_data.dependencies.len(), 2);

        let requests = package_data
            .dependencies
            .iter()
            .find(|d| d.purl.as_ref().unwrap().contains("requests"))
            .expect("Should find requests dependency");

        assert_eq!(requests.is_optional, Some(false));
        assert_eq!(
            requests.is_runtime,
            Some(true),
            "Non-optional package should have is_runtime=true"
        );

        let pytest = package_data
            .dependencies
            .iter()
            .find(|d| d.purl.as_ref().unwrap().contains("pytest"))
            .expect("Should find pytest dependency");

        assert_eq!(pytest.is_optional, Some(true));
        assert_eq!(
            pytest.is_runtime,
            Some(false),
            "Optional package should have is_runtime=false"
        );
    }
}
