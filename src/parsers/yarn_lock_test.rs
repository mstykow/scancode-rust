#[cfg(test)]
mod tests {
    use crate::parsers::yarn_lock::{
        detect_yarn_version, extract_namespace_and_name, parse_yarn_v1_requirement,
        parse_yarn_v2_resolution,
    };
    use crate::parsers::{PackageParser, YarnLockParser};
    use std::path::PathBuf;

    fn load_testdata_file(name: &str) -> PathBuf {
        PathBuf::from(format!("testdata/npm/{}", name))
            .canonicalize()
            .expect("Failed to find test data file")
    }

    // ===== File Matching Tests =====

    #[test]
    fn test_is_match_yarn_lock() {
        let valid_path = PathBuf::from("/some/path/yarn.lock");
        assert!(YarnLockParser::is_match(&valid_path));
    }

    #[test]
    fn test_is_not_match_package_json() {
        let invalid_path = PathBuf::from("/some/path/package.json");
        assert!(!YarnLockParser::is_match(&invalid_path));
    }

    // ===== Version Detection Tests =====

    #[test]
    fn test_detect_yarn_v2() {
        let content = r#"# This file is generated by running "yarn install"
__metadata:
  version: 6
"#;
        assert!(detect_yarn_version(content));
    }

    #[test]
    fn test_detect_yarn_v1() {
        let content = r#"# THIS IS AN AUTOGENERATED FILE
# yarn lockfile v1

abbrev@1:
  version "1.0.9"
"#;
        assert!(!detect_yarn_version(content));
    }

    // ===== Parsing Tests =====

    #[test]
    fn test_parse_yarn_v1_from_testdata() {
        let lock_path = load_testdata_file("yarn-v1.lock");
        let package_data = YarnLockParser::extract_first_package(&lock_path);

        assert_eq!(package_data.package_type, Some("npm".to_string()));
        assert!(!package_data.dependencies.is_empty());
    }

    #[test]
    fn test_parse_yarn_v2_from_testdata() {
        let lock_path = load_testdata_file("yarn-v2.lock");
        let package_data = YarnLockParser::extract_first_package(&lock_path);

        assert_eq!(package_data.package_type, Some("npm".to_string()));
        assert!(!package_data.dependencies.is_empty());

        for dep in &package_data.dependencies {
            assert_eq!(dep.is_pinned, Some(true));
        }
    }

    #[test]
    fn test_parse_scoped_packages_v1() {
        let content = r#"# THIS IS AN AUTOGENERATED FILE
# yarn lockfile v1

"@babel/core@^7.1.0":
  version "7.3.4"
  resolved "https://registry.yarnpkg.com/@babel/core/-/core-7.3.4.tgz"
  integrity sha512-test
  dependencies:
    "@babel/code-frame" "^7.0.0"
"#;

        let (_temp_dir, path) = create_temp_lock_file(content);
        let package_data = YarnLockParser::extract_first_package(&path);

        assert_eq!(package_data.dependencies.len(), 1);

        let dep = &package_data.dependencies[0];
        assert!(dep.purl.as_ref().unwrap().contains("%40babel"));

        let resolved = dep.resolved_package.as_ref().unwrap();
        assert_eq!(resolved.namespace, "@babel");
        assert_eq!(resolved.name, "core");
    }

    #[test]
    fn test_parse_scoped_packages_v2() {
        let content = r#"# This file is generated by running "yarn install"
__metadata:
  version: 6

"@actions/core@npm:1.2.6":
  version: 1.2.6
  resolution: "@actions/core@npm:1.2.6"
  checksum: 034e57fcb5f944d5fb0ef55be1b212dd88e23d1a50aaffda874cb94e8f4bfa633a66f108f26e81a7cce287cd2b349aa88c97d2023135c8879495326db37a7feb
  languageName: node
  linkType: hard
"#;

        let (_temp_dir, path) = create_temp_lock_file(content);
        let package_data = YarnLockParser::extract_first_package(&path);

        assert_eq!(package_data.dependencies.len(), 1);

        let dep = &package_data.dependencies[0];
        assert!(dep.purl.as_ref().unwrap().contains("%40actions"));

        let resolved = dep.resolved_package.as_ref().unwrap();
        assert_eq!(resolved.namespace, "@actions");
        assert_eq!(resolved.name, "core");
        assert_eq!(resolved.version, "1.2.6");
        assert!(resolved.sha512.is_some());
    }

    #[test]
    fn test_parse_v1_multiple_aliases() {
        let content = r#"# THIS IS AN AUTOGENERATED FILE
# yarn lockfile v1

"rimraf@2, rimraf@~2.5.1":
  version "2.5.4"
  resolved "https://registry.yarnpkg.com/rimraf/-/rimraf-2.5.4.tgz"
  integrity sha512-test
"#;

        let (_temp_dir, path) = create_temp_lock_file(content);
        let package_data = YarnLockParser::extract_first_package(&path);

        assert_eq!(package_data.dependencies.len(), 1);
        let dep = &package_data.dependencies[0];
        let requirement = dep.extracted_requirement.as_ref().unwrap();
        assert!(requirement.contains("2") || requirement.contains("~"));
    }

    #[test]
    fn test_v1_peer_dependencies_not_distinguished() {
        let content = r#"# THIS IS AN AUTOGENERATED FILE
# yarn lockfile v1

"express@^4.0.0":
  version "4.18.2"
  resolved "https://registry.yarnpkg.com/express/-/express-4.18.2.tgz"
  integrity sha512-test
  dependencies:
    body-parser "^1.20.0"
"#;

        let (_temp_dir, path) = create_temp_lock_file(content);
        let package_data = YarnLockParser::extract_first_package(&path);

        assert_eq!(package_data.dependencies.len(), 1);
        let dep = &package_data.dependencies[0];
        assert_eq!(dep.scope, Some("dependencies".to_string()));
    }

    /// Tests that yarn.lock v1 format does not distinguish dev dependencies.
    /// yarn.lock v1 only contains `dependencies`, with no dev/peer distinction.
    /// This is a known limitation of the yarn v1 lockfile format.
    #[test]
    fn test_v1_dev_dependencies_not_distinguished() {
        let content = r#"# THIS IS AN AUTOGENERATED FILE
# yarn lockfile v1

"jest@^29.0.0":
  version "29.5.0"
  resolved "https://registry.yarnpkg.com/jest/-/jest-29.5.0.tgz"
  integrity sha512-test
  dependencies:
    "@jest/core" "^29.5.0"
"#;

        let (_temp_dir, path) = create_temp_lock_file(content);
        let package_data = YarnLockParser::extract_first_package(&path);

        assert_eq!(package_data.dependencies.len(), 1);
        let dep = &package_data.dependencies[0];
        // yarn v1 lockfiles don't contain dev info, so everything is "dependencies"
        assert_eq!(dep.scope, Some("dependencies".to_string()));
        assert_eq!(dep.is_runtime, Some(true));
    }

    #[test]
    fn test_parse_v2_dependencies() {
        let content = r#"# This file is generated by running "yarn install"
__metadata:
  version: 6

"@babel/cli@npm:7.10.1":
  version: 7.10.1
  resolution: "@babel/cli@npm:7.10.1"
  dependencies:
    chokidar: ^2.1.8
    source-map: ^0.5.0
  checksum: test
  languageName: node
  linkType: hard
"#;

        let (_temp_dir, path) = create_temp_lock_file(content);
        let package_data = YarnLockParser::extract_first_package(&path);

        assert_eq!(package_data.dependencies.len(), 1);

        let resolved = package_data.dependencies[0]
            .resolved_package
            .as_ref()
            .unwrap();

        assert_eq!(resolved.dependencies.len(), 2);
    }

    #[test]
    fn test_parse_v2_peer_dependencies() {
        let content = r#"# This file is generated by running "yarn install"
__metadata:
  version: 6

"@babel/cli@npm:7.10.1":
  version: 7.10.1
  resolution: "@babel/cli@npm:7.10.1"
  peerDependencies:
    "@babel/core": ^7.0.0-0
  checksum: test
  languageName: node
  linkType: hard
"#;

        let (_temp_dir, path) = create_temp_lock_file(content);
        let package_data = YarnLockParser::extract_first_package(&path);

        assert_eq!(package_data.dependencies.len(), 1);

        let resolved = package_data.dependencies[0]
            .resolved_package
            .as_ref()
            .unwrap();

        assert_eq!(resolved.dependencies.len(), 1);
        let peer_dep = &resolved.dependencies[0];
        assert_eq!(peer_dep.scope, Some("peerDependencies".to_string()));
        assert_eq!(peer_dep.is_optional, Some(true));
        assert_eq!(peer_dep.is_runtime, Some(false));
    }

    // ===== Helper Tests =====

    #[test]
    fn test_extract_namespace_and_name_scoped() {
        let (namespace, name) = extract_namespace_and_name("@types/node");
        assert_eq!(namespace, "@types");
        assert_eq!(name, "node");
    }

    #[test]
    fn test_extract_namespace_and_name_regular() {
        let (namespace, name) = extract_namespace_and_name("express");
        assert_eq!(namespace, "");
        assert_eq!(name, "express");
    }

    #[test]
    fn test_parse_yarn_v1_requirement() {
        let (namespace, name, constraint) = parse_yarn_v1_requirement("express@^4.0.0");
        assert_eq!(namespace, "");
        assert_eq!(name, "express");
        assert_eq!(constraint, "^4.0.0");
    }

    #[test]
    fn test_parse_yarn_v1_requirement_scoped() {
        let (namespace, name, constraint) = parse_yarn_v1_requirement("@types/node@^18.0.0");
        assert_eq!(namespace, "@types");
        assert_eq!(name, "node");
        assert_eq!(constraint, "^18.0.0");
    }

    #[test]
    fn test_parse_yarn_v2_resolution() {
        let (namespace, name, version) = parse_yarn_v2_resolution("@actions/core@npm:1.2.6");
        assert_eq!(namespace, Some("@actions".to_string()));
        assert_eq!(name, "core");
        assert_eq!(version, "1.2.6");
    }

    // ===== Error Handling Tests =====

    #[test]
    fn test_invalid_yarn_v1_format() {
        let content = "invalid content without proper format";

        let (_temp_dir, path) = create_temp_lock_file(content);
        let package_data = YarnLockParser::extract_first_package(&path);

        assert_eq!(package_data.package_type, Some("npm".to_string()));
        assert!(package_data.dependencies.is_empty());
    }

    #[test]
    fn test_invalid_yarn_v2_yaml() {
        let content = r#"__metadata:"#;

        let (_temp_dir, path) = create_temp_lock_file(content);
        let package_data = YarnLockParser::extract_first_package(&path);

        assert_eq!(package_data.package_type, Some("npm".to_string()));
        assert!(package_data.dependencies.is_empty());
    }

    #[test]
    fn test_yarn_v2_malformed_yaml_graceful() {
        let path = PathBuf::from("testdata/yarn/malformed-v2/yarn.lock");
        let result = YarnLockParser::extract_first_package(&path);

        // Should return default PackageData, not panic
        assert_eq!(result.package_type, Some("npm".to_string()));
        assert!(result.dependencies.is_empty()); // No valid data extracted
        // Test passes if we get here (no panic occurred)
    }

    // ===== Helper Functions =====

    use tempfile::TempDir;

    fn create_temp_lock_file(content: &str) -> (TempDir, PathBuf) {
        let temp_dir = TempDir::new().expect("Failed to create temp dir");
        let lock_path = temp_dir.path().join("yarn.lock");
        std::fs::write(&lock_path, content).expect("Failed to write yarn.lock");
        (temp_dir, lock_path)
    }
}
