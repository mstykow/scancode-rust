# ADR 0005: Auto-Generated Documentation

**Status**: Accepted  
**Authors**: scancode-rust team  
**Supersedes**: None

## Context

With 40+ package ecosystems and 136+ file formats to document, maintaining accurate parser documentation is a significant challenge:

1. **Scale Problem**: Manual documentation for dozens of parsers is error-prone
2. **Staleness Risk**: Documentation easily gets out of sync with code
3. **Consistency**: Different contributors document parsers differently
4. **Discovery**: Users need to find which formats are supported
5. **Maintenance Burden**: Every parser addition requires manual doc updates

The Python ScanCode Toolkit solves this using a custom script (`regen_package_docs.py`) that extracts metadata from parser classes and generates reStructuredText documentation.

**Question**: How do we keep documentation accurate, comprehensive, and up-to-date as we add 40+ parsers?

## Decision

**Use a hybrid documentation approach: Auto-generate format tables from code metadata + manual architecture/guide documentation + Rust doc comments for API reference.**

### Documentation Strategy

```text
┌─────────────────────────────────────────────────────────┐
│                 Documentation Sources                    │
└─────────────────────────────────────────────────────────┘
           │                    │                  │
           ▼                    ▼                  ▼
    ┌─────────────┐     ┌──────────────┐   ┌────────────┐
    │   Parser    │     │ Doc Comments │   │   Manual   │
    │  Metadata   │     │   (/// //!)  │   │ Markdown   │
    │   (code)    │     │              │   │   Files    │
    └──────┬──────┘     └──────┬───────┘   └──────┬─────┘
           │                   │                   │
           │                   │                   │
           ▼                   ▼                   ▼
    ┌─────────────┐     ┌──────────────┐   ┌────────────┐
    │ Pre-commit  │     │  cargo doc   │   │   GitHub   │
    │    Hook     │     │  (docs.rs)   │   │   README   │
    │ (generate)  │     │              │   │   /docs/   │
    └──────┬──────┘     └──────────────┘   └────────────┘
           │
           ▼
    ┌──────────────────┐
    │ SUPPORTED_       │
    │ FORMATS.md       │
    │ (auto-generated) │
    └──────────────────┘
```

### Three Documentation Layers

#### 1. Auto-Generated Format Table

**Source**: Parser code metadata (trait implementations, file patterns)

**Output**: `docs/SUPPORTED_FORMATS.md`

**Generation**: Pre-commit hook extracts metadata and generates Markdown table

**Example**:

| Format | Package Type | File Patterns | Status |
|--------|--------------|---------------|--------|
| package.json | npm | `**/package.json` | ✅ Complete |
| Cargo.toml | cargo | `**/Cargo.toml` | ✅ Complete |
| pom.xml | maven | `**/pom.xml` | ✅ Complete |

**Implementation** (conceptual):

```rust
// In parser code
impl PackageParser for NpmParser {
    const PACKAGE_TYPE: &'static str = "npm";
    
    fn is_match(path: &Path) -> bool {
        matches!(
            path.file_name().and_then(|n| n.to_str()),
            Some("package.json" | "package-lock.json" | "npm-shrinkwrap.json")
        )
    }
}

// Generation script extracts this metadata
// and generates SUPPORTED_FORMATS.md
```

**Benefits**:

- Always accurate (generated from actual code)
- Comprehensive (covers all parsers automatically)
- Consistent format (same template for all)
- No manual maintenance (automated in pre-commit hook)

#### 2. Rust Doc Comments (API Reference)

**Source**: `///` and `//!` comments in source code

**Output**: docs.rs API documentation (generated by `cargo doc`)

**Target Audience**: Rust developers using scancode-rust as a library

**Example**:

```rust
//! Parser for npm package manifests.
//!
//! Extracts package metadata, dependencies, and license information from
//! npm manifest files (`package.json`, `package-lock.json`, `npm-shrinkwrap.json`).
//!
//! # Supported Formats
//! - `package.json` - Package manifest with metadata and dependencies
//! - `package-lock.json` - Lockfile with exact resolved versions (v1, v2, v3)
//! - `npm-shrinkwrap.json` - Alternative lockfile format
//! - `yarn.lock` - Yarn lockfile format
//! - `pnpm-lock.yaml` - pnpm lockfile format
//!
//! # Key Features
//! - Detects version pinning with `is_pinned` flag
//! - Extracts dependency scopes (dependencies, devDependencies, etc.)
//! - Generates proper PURLs for all dependency types
//! - Handles npm workspaces and monorepos
//!
//! # Implementation Notes
//! - Uses `serde_json` for zero-copy parsing
//! - Preserves string interpolation in version constraints
//! - Follows npm lockfile v1/v2/v3 specifications
//!
//! # Examples
//! ```
//! use scancode_rust::parsers::NpmParser;
//! use std::path::Path;
//!
//! let data = NpmParser::extract_package_data(Path::new("package.json"));
//! println!("Package: {} v{}", data.name.unwrap(), data.version.unwrap());
//! ```

/// Extracts package metadata from npm manifest files.
///
/// Returns `PackageData` with all available fields populated.
/// Returns a default structure if parsing fails (logs warning).
pub fn extract_package_data(path: &Path) -> PackageData {
    // Implementation
}
```

**Benefits**:

- Standard Rust documentation approach
- Integrated with IDE tooltips (rust-analyzer)
- Automatically published to docs.rs
- Supports doc tests (examples are tested)
- Searchable and linkable

#### 3. Manual Markdown Documentation

**Source**: Manually maintained files in `docs/` directory

**Output**: GitHub repository documentation

**Target Audience**: End users, contributors, architects

**Structure**:

```text
docs/
├── ARCHITECTURE.md           # System design
├── PARSER_GUIDE.md          # How to add parsers
├── TESTING.md               # Testing strategy
├── TESTING_STRATEGY.md      # Testing philosophy and guidelines
├── adr/                     # Architectural decisions
│   ├── 0001-trait-based-parsers.md
│   └── ...
└── improvements/            # Beyond-parity features
    ├── alpine-parser.md
    └── ...
```

**Benefits**:

- Explains "why" not just "what"
- Provides context for design decisions
- Documents trade-offs and alternatives
- Guides contributors on conventions

### Generation Workflow

#### Pre-Commit Hook

```bash
#!/bin/bash
# .git/hooks/pre-commit

# Format code
cargo fmt --all

# Generate documentation
cargo run --bin gen_parser_docs > docs/SUPPORTED_FORMATS.md

# Stage generated docs
git add docs/SUPPORTED_FORMATS.md
```

#### Documentation Generator (Conceptual)

```rust
// tools/gen_parser_docs.rs

fn main() {
    let mut table = MarkdownTable::new();
    table.header(&["Format", "Package Type", "File Patterns", "Status"]);
    
    // Iterate all parsers (using inventory or similar)
    for parser in scancode_rust::parsers::all() {
        table.row(&[
            parser.format_name(),
            parser.package_type(),
            parser.file_patterns().join(", "),
            parser.status(),
        ]);
    }
    
    println!("{}", table.render());
}
```

## Consequences

### Benefits

1. **Documentation Can't Go Stale**
   - Auto-generated from code ensures accuracy
   - Pre-commit hook enforces updates
   - Impossible to add parser without documenting it

2. **Consistency**
   - Same format for all parsers
   - Template-driven generation
   - Uniform presentation

3. **Discoverability**
   - Single source of truth (SUPPORTED_FORMATS.md)
   - Easy to search and filter
   - Clear status indicators

4. **Low Maintenance**
   - No manual doc updates for format table
   - Contributors only write code
   - Automation handles the rest

5. **Multi-Audience**
   - End users: README + SUPPORTED_FORMATS.md
   - API users: docs.rs documentation
   - Contributors: Architecture docs + ADRs

### Trade-offs

1. **Build Complexity**
   - Requires documentation generation tooling
   - Pre-commit hook adds setup step
   - **Acceptable**: One-time setup, huge long-term benefit

2. **Partial Automation**
   - Can't auto-generate architecture decisions or guides
   - Still need manual ADRs and improvement docs
   - **Acceptable**: Hybrid approach balances automation and flexibility

3. **Rust Doc Comments Required**
   - Contributors must write `///` comments
   - More verbose than Python docstrings
   - **Acceptable**: Standard Rust practice, enforced by `#![deny(missing_docs)]`

## Alternatives Considered

### 1. Fully Manual Documentation

**Approach**: Write and maintain all documentation by hand.

```markdown
# Supported Formats

## npm
- package.json (✅ Complete)
- package-lock.json (✅ Complete)
- ...
```

**Rejected because**:

- High maintenance burden (40+ parsers)
- Prone to staleness (docs drift from code)
- Inconsistent formatting (different contributors)
- Easy to forget updating when adding parsers

### 2. Python-Style Registration System

**Approach**: Use runtime metadata registration (like Python's class attributes).

```rust
pub struct NpmParser {
    metadata: ParserMetadata {
        description: "npm package.json parser",
        path_patterns: vec!["**/package.json"],
        // ...
    }
}
```

**Rejected because**:

- Not idiomatic Rust (prefer compile-time)
- Requires runtime introspection
- More complex than trait-based approach
- Doesn't leverage Rust's type system

### 3. Macro-Based Registration

**Approach**: Use proc macros to automatically register parsers.

```rust
#[register_parser(
    package_type = "npm",
    patterns = ["**/package.json"],
    description = "npm package manifest"
)]
pub struct NpmParser;
```

**Partial acceptance**: This could work, but adds complexity.

**Why not primary approach**:

- Proc macros add compile-time overhead
- Harder to debug
- Less explicit than trait methods
- Can achieve same result with simpler build script

### 4. No Auto-Generation (Rust Doc Only)

**Approach**: Rely solely on `cargo doc` output, no separate SUPPORTED_FORMATS.md.

**Rejected because**:

- Not user-friendly (API docs are developer-focused)
- Requires users to browse docs.rs
- No single-page format reference
- Harder to search and filter

## Python Reference Comparison

**Python Approach**:

- **Auto-generation**: Manual script execution
- **Format**: reStructuredText
- **Metadata source**: Python class attributes

**Our Rust Approach**:

- **Auto-generation**: Pre-commit hook
- **Format**: Markdown
- **Metadata source**: Trait implementations
- **Additional**: cargo doc for API reference

## Related ADRs

- [ADR 0001: Trait-Based Parser Architecture](0001-trait-based-parsers.md) - Trait system enables metadata extraction
- [ADR 0003: Golden Test Strategy](0003-golden-test-strategy.md) - Testing validates documentation accuracy

## References

- Rust documentation best practices: [Rust API Guidelines](https://rust-lang.github.io/api-guidelines/documentation.html)
